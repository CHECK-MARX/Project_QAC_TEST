#ifndef __QAC_INCLUDE_scoped_allocator__
#define __QAC_INCLUDE_scoped_allocator__

// Some flags to control how closely the standard is followed
#include <qac_config.h>
#include <utility>
#include <memory>

// END BLOCK prefix

__QAC_BEGIN_NAMESPACE

#if defined (__cplusplus) && (__cplusplus >= 201103)

// scoped allocator adaptor
template <class OuterAlloc, class... InnerAlloc> class scoped_allocator_adaptor;
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator== ( const scoped_allocator_adaptor<OuterA1, InnerAllocs...> & a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...> & b ) noexcept;
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator!= ( const scoped_allocator_adaptor<OuterA1, InnerAllocs...> & a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...> & b ) noexcept;

template <class OuterAlloc, class... InnerAllocs> class scoped_allocator_adaptor : public OuterAlloc
{
private:
  using OuterTraits = allocator_traits<OuterAlloc>;

public:
  using outer_allocator_type = OuterAlloc;
  using inner_allocator_type = OuterAlloc;
  using value_type = typename OuterTraits::value_type;
  using size_type = typename OuterTraits::size_type;
  using difference_type = typename OuterTraits::difference_type;
  using pointer = typename OuterTraits::pointer;
  using const_pointer = typename OuterTraits::const_pointer;
  using void_pointer = typename OuterTraits::void_pointer;
  using const_void_pointer = typename OuterTraits::const_void_pointer;
  using propagate_on_container_copy_assignment = false_type;
  using propagate_on_container_move_assignment = false_type;
  using propagate_on_container_swap = false_type;
  using is_always_equal = false_type;
  template <class Tp> struct rebind
  {
  };
  scoped_allocator_adaptor ();
  template <class OuterA2>
  scoped_allocator_adaptor ( OuterA2 && outerAlloc, const InnerAllocs &... innerAllocs ) noexcept;
  scoped_allocator_adaptor ( const scoped_allocator_adaptor & other ) noexcept;
  scoped_allocator_adaptor ( scoped_allocator_adaptor && other ) noexcept;
  template <class OuterA2>
  scoped_allocator_adaptor ( const scoped_allocator_adaptor<OuterA2, InnerAllocs...> & other ) noexcept;
  template <class OuterA2>
  scoped_allocator_adaptor ( scoped_allocator_adaptor<OuterA2, InnerAllocs...> && other ) noexcept;
  scoped_allocator_adaptor & operator= ( const scoped_allocator_adaptor & ) = default;
  scoped_allocator_adaptor & operator= ( scoped_allocator_adaptor && ) = default;
  ~scoped_allocator_adaptor ();
  inner_allocator_type & inner_allocator () noexcept;
  const inner_allocator_type & inner_allocator () const noexcept;
  outer_allocator_type & outer_allocator () noexcept;
  const outer_allocator_type & outer_allocator () const noexcept;
  pointer allocate ( size_type n );
  pointer allocate ( size_type n, const_void_pointer hint );
  void deallocate ( pointer p, size_type n );
  size_type max_size () const;
  template <class T, class... Args> void construct ( T * p, Args &&... args );
  template <class T1, class T2> void construct ( pair<T1, T2> * p );
  template <class T1, class T2, class U, class V> void construct ( pair<T1, T2> * p, U && x, V && y );
  template <class T1, class T2, class U, class V> void construct ( pair<T1, T2> * p, const pair<U, V> & x );
  template <class T1, class T2, class U, class V> void construct ( pair<T1, T2> * p, pair<U, V> && x );
  template <class T> void destroy ( T * p );
  scoped_allocator_adaptor select_on_container_copy_construction () const;
};

template <class OuterAlloc, class... InnerAllocs>
scoped_allocator_adaptor ( OuterAlloc, InnerAllocs... )
  -> scoped_allocator_adaptor<OuterAlloc, InnerAllocs...>;

template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator== ( const scoped_allocator_adaptor<OuterA1, InnerAllocs...> & a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...> & b ) noexcept;

template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator!= ( const scoped_allocator_adaptor<OuterA1, InnerAllocs...> & a,
                  const scoped_allocator_adaptor<OuterA2, InnerAllocs...> & b ) noexcept;


// defined (__cplusplus) && (__cplusplus >= 201103)
#endif

__QAC_END_NAMESPACE


// BEGIN BLOCK postfix
#endif // ends __QAC_INCLUDE_scoped_allocator__
// END BLOCK postfix
