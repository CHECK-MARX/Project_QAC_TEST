
// BEGIN BLOCK prefix

#ifndef __QAC_INCLUDE_string_view__
#define __QAC_INCLUDE_string_view__

// Some flags to control how closely the standard is followed
#include <qac_config.h>

// END BLOCK prefix

#include <qac_iterator.h>
#include <char_traits.h>
#include <iosfwd>               //  for  istream,  ostream

__QAC_BEGIN_NAMESPACE

  // 24.4.2, class template basic_string_view
  template <class charT, class traits = char_traits<charT>> class basic_string_view;

  // 24.4.3, non-member comparison functions
  template <class charT, class traits>
  constexpr bool operator== ( basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y ) noexcept;
  template <class charT, class traits>
  constexpr bool operator!= ( basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y ) noexcept;
  template <class charT, class traits>
  constexpr bool operator< ( basic_string_view<charT, traits> x,
                             basic_string_view<charT, traits> y ) noexcept;
  template <class charT, class traits>
  constexpr bool operator> ( basic_string_view<charT, traits> x,
                             basic_string_view<charT, traits> y ) noexcept;
  template <class charT, class traits>
  constexpr bool operator<= ( basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y ) noexcept;
  template <class charT, class traits>
  constexpr bool operator>= ( basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y ) noexcept;
  // see 24.4.3, sufficient additional overloads of comparison functions
  // 24.4.4, inserters and extractors
  template <class charT, class traits>
  basic_ostream<charT, traits> & operator<< ( basic_ostream<charT, traits> & os,
                                              basic_string_view<charT, traits> str );
  // basic_string_view typedef names
  using string_view = basic_string_view<char>;
  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;
  using wstring_view = basic_string_view<wchar_t>;
#if __cplusplus >= 202002L
  using u8string_view = basic_string_view<char8_t>;
#endif

  // 24.4.5, hash support
  template <class T> struct hash;
  template <> struct hash<string_view>;
  template <> struct hash<u16string_view>;
  template <> struct hash<u32string_view>;
  template <> struct hash<wstring_view>;

  inline namespace literals
  {
    inline namespace string_view_literals
    {
      // 24.4.6, suffix for basic_string_view literals

      constexpr string_view operator""sv ( const char * str, size_t len ) noexcept;
      constexpr u16string_view operator""sv ( const char16_t * str, size_t len ) noexcept;
      constexpr u32string_view operator""sv ( const char32_t * str, size_t len ) noexcept;
      constexpr wstring_view operator""sv ( const wchar_t * str, size_t len ) noexcept;
    }
  }

  template <class charT, class traits = char_traits<charT>> class basic_string_view
  {
  public:
    // types
    using traits_type = traits;
    using value_type = charT;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using const_iterator = __normal_iterator<const_pointer, basic_string_view<charT, traits> >;
    using iterator = const_iterator;
    using const_reverse_iterator = reverse_iterator<const_iterator>;
    using reverse_iterator = const_reverse_iterator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    static constexpr size_type npos = size_type ( -1 );
    // 24.4.2.1, construction and assignment
    constexpr basic_string_view () noexcept;
    constexpr basic_string_view ( const basic_string_view & ) noexcept = default;
    constexpr basic_string_view & operator= ( const basic_string_view & ) noexcept = default;
    constexpr basic_string_view ( const charT * str );
    constexpr basic_string_view ( const charT * str, size_type len );
  #if __cplusplus >= 202002L
    template< class It, class End >
    constexpr basic_string_view( It first, End last );
  #endif
    // 24.4.2.2, iterator support
    constexpr const_iterator begin () const noexcept;
    constexpr const_iterator end () const noexcept;
    constexpr const_iterator cbegin () const noexcept;
    constexpr const_iterator cend () const noexcept;
    constexpr const_reverse_iterator rbegin () const noexcept;
    constexpr const_reverse_iterator rend () const noexcept;
    constexpr const_reverse_iterator crbegin () const noexcept;
    constexpr const_reverse_iterator crend () const noexcept;
    // 24.4.2.3, capacity
    constexpr size_type size () const noexcept;
    constexpr size_type length () const noexcept;
    constexpr size_type max_size () const noexcept;
    constexpr bool empty () const noexcept;
    // 24.4.2.4, element access
    constexpr const_reference operator[] ( size_type pos ) const;
    constexpr const_reference at ( size_type pos ) const;
    constexpr const_reference front () const;
    constexpr const_reference back () const;
    constexpr const_pointer data () const noexcept;
    // 24.4.2.5, modifiers
    constexpr void remove_prefix ( size_type n );
    constexpr void remove_suffix ( size_type n );
    constexpr void swap ( basic_string_view & s ) noexcept;
    // 24.4.2.6, string operations
    size_type copy ( charT * s, size_type n, size_type pos = 0 ) const;
    constexpr basic_string_view substr ( size_type pos = 0, size_type n = npos ) const;
    constexpr int compare ( basic_string_view s ) const noexcept;
    constexpr int compare ( size_type pos1, size_type n1, basic_string_view s ) const;
    constexpr int
    compare ( size_type pos1, size_type n1, basic_string_view s, size_type pos2, size_type n2 ) const;
    constexpr int compare ( const charT * s ) const;
    constexpr int compare ( size_type pos1, size_type n1, const charT * s ) const;
    constexpr int compare ( size_type pos1, size_type n1, const charT * s, size_type n2 ) const;
    constexpr size_type find ( basic_string_view s, size_type pos = 0 ) const noexcept;
    constexpr size_type find ( charT c, size_type pos = 0 ) const noexcept;
    constexpr size_type find ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type find ( const charT * s, size_type pos = 0 ) const;
    constexpr size_type rfind ( basic_string_view s, size_type pos = npos ) const noexcept;
    constexpr size_type rfind ( charT c, size_type pos = npos ) const noexcept;
    constexpr size_type rfind ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type rfind ( const charT * s, size_type pos = npos ) const;
    constexpr size_type find_first_of ( basic_string_view s, size_type pos = 0 ) const noexcept;
    constexpr size_type find_first_of ( charT c, size_type pos = 0 ) const noexcept;
    constexpr size_type find_first_of ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type find_first_of ( const charT * s, size_type pos = 0 ) const;
    constexpr size_type find_last_of ( basic_string_view s, size_type pos = npos ) const noexcept;
    constexpr size_type find_last_of ( charT c, size_type pos = npos ) const noexcept;
    constexpr size_type find_last_of ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type find_last_of ( const charT * s, size_type pos = npos ) const;
    constexpr size_type find_first_not_of ( basic_string_view s, size_type pos = 0 ) const noexcept;
    constexpr size_type find_first_not_of ( charT c, size_type pos = 0 ) const noexcept;
    constexpr size_type find_first_not_of ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type find_first_not_of ( const charT * s, size_type pos = 0 ) const;
    constexpr size_type find_last_not_of ( basic_string_view s, size_type pos = npos ) const noexcept;
    constexpr size_type find_last_not_of ( charT c, size_type pos = npos ) const noexcept;
    constexpr size_type find_last_not_of ( const charT * s, size_type pos, size_type n ) const;
    constexpr size_type find_last_not_of ( const charT * s, size_type pos = npos ) const;
  };

__QAC_END_NAMESPACE

// BEGIN BLOCK postfix
// Updated by paul on Tue Jun  8 11:15:39 IST 1999
#endif // ends __QAC_INCLUDE_string__
// END BLOCK postfix
