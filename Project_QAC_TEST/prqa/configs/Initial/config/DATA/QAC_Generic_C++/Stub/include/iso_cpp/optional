#ifndef __QAC_INCLUDE_system_error__
#define __QAC_INCLUDE_system_error__

// Some flags to control how closely the standard is followed
#include <qac_config.h>

#include <iosfwd>
#include <stdexcept>
#include <utility>
#include <type_traits>
#include <initializer_list>

__QAC_BEGIN_NAMESPACE

struct nullopt_t{};
inline constexpr nullopt_t nullopt();

template <class T> class optional;

// 23.6.6, relational operators
template <class T, class U>
constexpr bool operator==(const optional<T>&, const optional<U>&);
template <class T, class U>
constexpr bool operator!=(const optional<T>&, const optional<U>&);

// 23.6.7, comparison with nullopt
template <class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
template <class T> constexpr bool operator==(nullopt_t, const optional<T>&) noexcept;
template <class T> constexpr bool operator!=(const optional<T>&, nullopt_t) noexcept;
template <class T> constexpr bool operator!=(nullopt_t, const optional<T>&) noexcept;

// 23.6.8, comparison with T
template <class T, class U> constexpr bool operator==(const optional<T>&, const U&);
template <class T, class U> constexpr bool operator==(const U&, const optional<T>&);
template <class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
template <class T, class U> constexpr bool operator!=(const U&, const optional<T>&);


template <class T> class optional
{
public:
  using value_type = T;
  // 23.6.3.1, constructors
  constexpr optional () noexcept;
  constexpr optional ( nullopt_t ) noexcept;
  constexpr optional ( const optional & );
  constexpr optional ( optional && ) noexcept;
  template <class... Args> constexpr explicit optional ( in_place_t, Args &&... );
  template <class U, class... Args>
  constexpr explicit optional ( in_place_t, initializer_list<U>, Args &&... );
  template <class U = T> constexpr optional ( U && );
  template <class U> optional ( const optional<U> & );
  template <class U> optional ( optional<U> && );
  // 23.6.3.2, destructor
  ~optional ();
  // 23.6.3.3, assignment
  optional & operator= ( nullopt_t ) noexcept;
  optional & operator= ( const optional & );
  optional & operator= ( optional && ) noexcept;
  template <class U = T> optional & operator= ( U && );
  template <class U> optional & operator= ( const optional<U> & );
  template <class U> optional & operator= ( optional<U> && );
  template <class... Args> T & emplace ( Args &&... );
  template <class U, class... Args> T & emplace ( initializer_list<U>, Args &&... );
  // 23.6.3.4, swap
  void swap ( optional & ) noexcept;
  // 23.6.3.5, observers
  constexpr const T * operator->() const;
  constexpr T * operator->();
  constexpr const T & operator* () const &;
  constexpr T & operator* () &;
  constexpr T && operator* () &&;
  constexpr const T && operator* () const &&;
  constexpr explicit operator bool () const noexcept;
  constexpr bool has_value () const noexcept;
  constexpr const T & value () const &;
  constexpr T & value () &;
  constexpr T && value () &&;
  constexpr const T && value () const &&;
  template <class U> constexpr T value_or ( U && ) const &;
  template <class U> constexpr T value_or ( U && ) &&;
  // 23.6.3.6, modifiers
  void reset () noexcept;

private:
  T * val; // exposition only
};

__QAC_END_NAMESPACE

// BEGIN BLOCK postfix
// Updated by paul on Tue Jun  8 11:15:38 IST 1999
#endif // ends __QAC_INCLUDE_numeric__
// END BLOCK postfix
