#ifndef __QAC_INCLUDE_random__
#define __QAC_INCLUDE_random__

// Some flags to control how closely the standard is followed
#include <qac_config.h>

#include <cstdint>
#include <initializer_list>
#include <iterator>
#include <limits>
#include <string>

__QAC_BEGIN_NAMESPACE

// 29.6.3.1, class template linear_congruential_engine
template <class UIntType, UIntType a, UIntType c, UIntType m> class linear_congruential_engine;

// 29.6.3.2, class template mersenne_twister_engine
template <class UIntType,
          size_t w,
          size_t n,
          size_t m,
          size_t r,
          UIntType a,
          size_t u,
          UIntType d,
          size_t s,
          UIntType b,
          size_t t,
          UIntType c,
          size_t l,
          UIntType f>
class mersenne_twister_engine;
// 29.6.3.3, class template subtract_with_carry_engine
template <class UIntType, size_t w, size_t s, size_t r> class subtract_with_carry_engine;
// 29.6.4.2, class template discard_block_engine
template <class Engine, size_t p, size_t r> class discard_block_engine;
// 29.6.4.3, class template independent_bits_engine
template <class Engine, size_t w, class UIntType> class independent_bits_engine;
// 29.6.4.4, class template shuffle_order_engine
template <class Engine, size_t k> class shuffle_order_engine;

// 29.6.5, engines and engine adaptors with predefined parameters
using minstd_rand0 = std::linear_congruential_engine <std::uint_fast32_t, 16807, 0, 2147483647>;
using minstd_rand = std::linear_congruential_engine <std::uint_fast32_t, 48271, 0, 2147483647>;
using mt19937 = mersenne_twister_engine<std::uint_fast32_t,
                                        32,
                                        624,
                                        397,
                                        31,
                                        0x9908b0df,
                                        11,
                                        0xffffffff,
                                        7,
                                        0x9d2c5680,
                                        15,
                                        0xefc60000,
                                        18,
                                        1812433253>;
using mt19937_64 = std::mersenne_twister_engine <std::uint_fast64_t, 64, 312, 156, 31,
                             0xb5026f5aa96619e9, 29,
                             0x5555555555555555, 17,
                             0x71d67fffeda60000, 37,
                             0xfff7eee000000000, 43, 6364136223846793005>;
using ranlux24_base = std::subtract_with_carry_engine <std::uint_fast32_t, 24, 10, 24>;
using ranlux48_base = std::subtract_with_carry_engine <std::uint_fast64_t, 48, 5, 12>;
using ranlux24 = std::discard_block_engine <std::ranlux24_base, 223, 23>;
using ranlux48 = std::discard_block_engine <std::ranlux48_base, 389, 11>;
using knuth_b = std::shuffle_order_engine<std::minstd_rand0, 256>;
using default_random_engine = mt19937;

// 29.6.6, class random_device
class random_device;
// 29.6.7.1, class seed_seq
class seed_seq;
// 29.6.7.2, function template generate_canonical
template <class RealType, size_t bits, class URBG> RealType generate_canonical (URBG & g);

// 29.6.8.2.1, class template uniform_int_distribution
template <class IntType = int> class uniform_int_distribution;
// 29.6.8.2.2, class template uniform_real_distribution
template <class RealType = double> class uniform_real_distribution;
// 29.6.8.3.1, class bernoulli_distribution
class bernoulli_distribution;
// 29.6.8.3.2, class template binomial_distribution
template <class IntType = int> class binomial_distribution;
// 29.6.8.3.3, class template geometric_distribution
template <class IntType = int> class geometric_distribution;
// 29.6.8.3.4, class template negative_binomial_distribution
template <class IntType = int> class negative_binomial_distribution;
// 29.6.8.4.1, class template poisson_distribution
template <class IntType = int> class poisson_distribution;
// 29.6.8.4.2, class template exponential_distribution
template <class RealType = double> class exponential_distribution;
// 29.6.8.4.3, class template gamma_distribution
template <class RealType = double> class gamma_distribution;
// 29.6.8.4.4, class template weibull_distribution
template <class RealType = double> class weibull_distribution;
// 29.6.8.4.5, class template extreme_value_distribution
template <class RealType = double> class extreme_value_distribution;
// 29.6.8.5.1, class template normal_distribution
template <class RealType = double> class normal_distribution;
// 29.6.8.5.2, class template lognormal_distribution
template <class RealType = double> class lognormal_distribution;
// 29.6.8.5.3, class template chi_squared_distribution
template <class RealType = double> class chi_squared_distribution;
// 29.6.8.5.4, class template cauchy_distribution
template <class RealType = double> class cauchy_distribution;
// 29.6.8.5.5, class template fisher_f_distribution
template <class RealType = double> class fisher_f_distribution;
// 29.6.8.5.6, class template student_t_distribution
template <class RealType = double> class student_t_distribution;
// 29.6.8.6.1, class template discrete_distribution
template <class IntType = int> class discrete_distribution;
// 29.6.8.6.2, class template piecewise_constant_distribution
template <class RealType = double> class piecewise_constant_distribution;
// 29.6.8.6.3, class template piecewise_linear_distribution
template <class RealType = double> class piecewise_linear_distribution;

template <class UIntType, UIntType a, UIntType c, UIntType m>
class linear_congruential_engine
{
public:
  // types
  using result_type = UIntType;

  // engine characteristics
  static constexpr UIntType multiplier = a;
  static constexpr UIntType increment = c;
  static constexpr UIntType modulus = m;
  static constexpr UIntType default_seed = 1;

  static constexpr result_type min ()
  {
    return 0;
  }
  static constexpr result_type max ()
  {
    return linear_congruential_engine::modulus - 1;
  }

  // constructors and seeding functions
  explicit linear_congruential_engine (result_type value = default_seed);
  template <class Sseq> explicit linear_congruential_engine (Sseq & q);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);

  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class UIntType,
          size_t w,
          size_t n,
          size_t m,
          size_t r,
          UIntType a,
          size_t u,
          UIntType d,
          size_t s,
          UIntType b,
          size_t t,
          UIntType c,
          size_t l,
          UIntType f>
class mersenne_twister_engine
{
public:
  // types
  using result_type = UIntType;
  // engine characteristics
  static constexpr size_t word_size = w;
  static constexpr size_t state_size = n;

  static constexpr size_t shift_size = m;
  static constexpr size_t mask_bits = r;
  static constexpr UIntType xor_mask = a;
  static constexpr size_t tempering_u = u;
  static constexpr UIntType tempering_d = d;
  static constexpr size_t tempering_s = s;
  static constexpr UIntType tempering_b = b;
  static constexpr size_t tempering_t = t;
  static constexpr UIntType tempering_c = c;
  static constexpr size_t tempering_l = l;
  static constexpr UIntType initialization_multiplier = f;
  static constexpr result_type min ()
  {
    return 0;
  }
  static constexpr result_type max ()
  {
    return (1 << mersenne_twister_engine::word_size) - 1;
  }
  static constexpr result_type default_seed = 5489u;
  // constructors and seeding functions
  explicit mersenne_twister_engine (result_type value = default_seed);
  template <class Sseq> explicit mersenne_twister_engine (Sseq & q);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);
  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class UIntType, size_t w, size_t s, size_t r>
class subtract_with_carry_engine
{
public:
  // types
  using result_type = UIntType;

  // engine characteristics
  static constexpr UIntType word_size = w;
  static constexpr UIntType short_lag = s;
  static constexpr UIntType long_lag = r;
  static constexpr UIntType default_seed = 1;

  static constexpr result_type min ()
  {
    return 0;
  }
  static constexpr result_type max ()
  {
    return (1 << subtract_with_carry_engine::word_size) - 1;
  }

  // constructors and seeding functions
  explicit subtract_with_carry_engine (result_type value = default_seed);
  template <class Sseq> explicit subtract_with_carry_engine (Sseq & q);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);

  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class Engine, size_t p, size_t r>
class discard_block_engine
{
public:
  // types
  using result_type = typename Engine::result_type;

  // engine characteristics
  static constexpr size_t block_size = p;
  static constexpr size_t used_size = r;

  static constexpr result_type min ()
  {
    return Engine::min ();
  }
  static constexpr result_type max ()
  {
    return Engine::max ();
  }

  // constructors and seeding functions
  explicit discard_block_engine (result_type value = Engine::default_seed);
  template <class Sseq> explicit discard_block_engine (Sseq & q);
  explicit discard_block_engine (Engine const & e);
  explicit discard_block_engine (Engine && e);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);

  // underlying engine
  Engine const & base () const noexcept;

  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class Engine, size_t w, class UIntType>
class independent_bits_engine
{
public:
  // types
  using result_type = UIntType;

  // engine characteristics
  // none

  static constexpr result_type min ()
  {
    return Engine::min ();
  }
  static constexpr result_type max ()
  {
    return Engine::max ();
  }

  // constructors and seeding functions
  explicit independent_bits_engine (result_type value = Engine::default_seed);
  template <class Sseq> explicit independent_bits_engine (Sseq & q);
  explicit independent_bits_engine (Engine const & e);
  explicit independent_bits_engine (Engine && e);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);

  // underlying engine
  Engine const & base () const noexcept;

  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class Engine, size_t k>
class shuffle_order_engine
{
public:
  // types
  using result_type = typename Engine::result_type;

  // engine characteristics
  static constexpr size_t table_size = k;

  static constexpr result_type min ()
  {
    return Engine::min ();
  }
  static constexpr result_type max ()
  {
    return Engine::max ();
  }

  // constructors and seeding functions
  explicit shuffle_order_engine (result_type value = Engine::default_seed);
  template <class Sseq> explicit shuffle_order_engine (Sseq & q);
  explicit shuffle_order_engine (Engine const & e);
  explicit shuffle_order_engine (Engine && e);
  void seed (result_type value = default_seed);
  template <class Sseq> void seed (Sseq & q);

  // underlying engine
  Engine const & base () const noexcept;

  // generating functions
  result_type operator() ();
  void discard (unsigned long long z);
};

template <class IntType = int> class uniform_int_distribution
{
public:
  // types
  using result_type = IntType;
  struct param_type
  {
  };
  // constructors and reset functions
  explicit uniform_int_distribution (IntType a = 0, IntType b = numeric_limits<IntType>::max ());
  explicit uniform_int_distribution (const param_type & parm);
  void reset ();
  // generating functions
  template <class URBG> result_type operator() (URBG & g);
  template <class URBG> result_type operator() (URBG & g, const param_type & parm);
  // property functions
  result_type a () const;
  result_type b () const;
  param_type param () const;
  void param (const param_type & parm);
  result_type min () const;
  result_type max () const;
};

class random_device
{
public:
  // types
  using result_type = unsigned int;
  // generator characteristics
  static constexpr result_type min ()
  {
    return numeric_limits<result_type>::min ();
  }
  static constexpr result_type max ()
  {
    return numeric_limits<result_type>::max ();
  }
  // constructors
  explicit random_device (const string & token = "");
  // generating functions
  result_type operator() ();
  // property functions
  double entropy () const noexcept;
  // no copy functions
  random_device (const random_device &) = delete;
  void operator= (const random_device &) = delete;
};

__QAC_END_NAMESPACE

#endif
